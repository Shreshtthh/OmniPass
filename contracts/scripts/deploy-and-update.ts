// contracts/scripts/deploy-and-update.ts
import hre from "hardhat";
import fs from 'fs';
import path from 'path';
import { Signer, TransactionReceipt } from "ethers";
import { OmniPassCredential } from "../typechain-types";

/**
 * Manual transaction polling to handle ZetaChain network sync delays
 */
async function waitForTransactionWithTimeout(txHash: string, timeoutMs = 180000): Promise<TransactionReceipt | null> {
    const { ethers } = hre;
    const provider = ethers.provider;
    const startTime = Date.now();

    console.log(`üîç Monitoring transaction: ${txHash}`);

    while (Date.now() - startTime < timeoutMs) {
        try {
            const receipt = await provider.getTransactionReceipt(txHash);
            if (receipt) {
                console.log(`‚úÖ Transaction confirmed in block ${receipt.blockNumber}`);
                return receipt;
            }
        } catch (error) {
            // Ignore errors and continue polling - handles ZetaChain sync delays
        }

        await new Promise(resolve => setTimeout(resolve, 5000));
        console.log("üîÑ Waiting for network sync...");
    }

    console.log("‚è∞ Transaction timeout reached");
    return null;
}

/**
 * Deploy contract with retry logic
 */
async function deployWithRetry(contractName: string, args: any[] = [], maxRetries = 3): Promise<OmniPassCredential> {
    const { ethers } = hre;
    const contractFactory = await ethers.getContractFactory(contractName);
    
    for (let i = 0; i < maxRetries; i++) {
        try {
            console.log(`üîÑ Deploying ${contractName} (attempt ${i + 1}/${maxRetries})...`);

            // Deploy with proper typing
            const contract = (await contractFactory.deploy(...args)) as unknown as OmniPassCredential;
            const deployTx = contract.deploymentTransaction();
            
            if (!deployTx) {
                throw new Error("Deployment transaction not found");
            }

            console.log(`üì§ Transaction sent: ${deployTx.hash}`);

            // Use manual polling instead of waitForDeployment()
            const receipt = await waitForTransactionWithTimeout(deployTx.hash, 180000);

            if (receipt) {
                console.log(`‚úÖ ${contractName} deployed at: ${await contract.getAddress()}`);
                return contract;
            } else {
                throw new Error("Transaction timeout - network sync delay");
            }

        } catch (error: any) {
            console.log(`‚ùå Attempt ${i + 1} failed:`, error.message);

            if (i === maxRetries - 1) {
                throw error;
            }

            console.log("‚è≥ Waiting 15 seconds before retry...");
            await new Promise(resolve => setTimeout(resolve, 15000));
        }
    }

    throw new Error("All deployment attempts failed");
}

/**
 * Execute transaction with retry logic
 */
async function executeTransactionWithRetry(
    txPromise: () => Promise<any>, 
    description: string, 
    maxRetries = 3
): Promise<TransactionReceipt | null> {
    for (let i = 0; i < maxRetries; i++) {
        try {
            console.log(`üîÑ ${description} (attempt ${i + 1}/${maxRetries})...`);

            const tx = await txPromise();
            console.log(`üì§ Transaction sent: ${tx.hash}`);

            const receipt = await waitForTransactionWithTimeout(tx.hash, 120000);

            if (receipt) {
                console.log(`‚úÖ ${description} completed successfully`);
                return receipt;
            } else {
                throw new Error("Transaction timeout");
            }

        } catch (error: any) {
            console.log(`‚ùå Attempt ${i + 1} failed:`, error.message);

            if (i === maxRetries - 1) {
                throw error;
            }

            console.log("‚è≥ Waiting before retry...");
            await new Promise(resolve => setTimeout(resolve, 10000));
        }
    }

    return null;
}

async function updateBackendConfig(address: string, abi: any[]) {
    console.log("üîß Updating backend configuration...");
    
    const backendConfigPath = path.join(__dirname, '../../backend/src/config/contracts.ts');
    const backendConfig = `// Auto-generated by deployment script - TESTNET CONFIGURATION
export const CONTRACT_CONFIG = {
  OMNIPASS_CREDENTIAL: {
    address: "${address}",
    chainId: 7001,
    network: "zetachain-testnet"
  }
};

export const OMNIPASS_ABI = ${JSON.stringify(abi, null, 2)};

export const SUPPORTED_CHAINS = {
  SEPOLIA: {
    chainId: 11155111,
    name: "Sepolia",
    rpcUrl: process.env.SEPOLIA_RPC_URL || "https://eth-sepolia.g.alchemy.com/v2/" + process.env.ALCHEMY_API_KEY,
    testnet: true
  },
  AMOY: {
    chainId: 80002,
    name: "Polygon Amoy", 
    rpcUrl: process.env.AMOY_RPC_URL || "https://rpc-amoy.polygon.technology/",
    testnet: true
  },
  ZETACHAIN_TESTNET: {
    chainId: 7001,
    name: "ZetaChain Testnet",
    rpcUrl: "https://zetachain-athens-evm.blockpi.network/v1/rpc/public",
    testnet: true
  }
};
`;
    
    const backendConfigDir = path.dirname(backendConfigPath);
    if (!fs.existsSync(backendConfigDir)) {
        fs.mkdirSync(backendConfigDir, { recursive: true });
    }
    
    fs.writeFileSync(backendConfigPath, backendConfig);
    
    const backendEnvPath = path.join(__dirname, '../../backend/.env.example');
    const backendEnvContent = `# TESTNET CONFIGURATION
# Blockchain Configuration
ALCHEMY_API_KEY=your_alchemy_api_key_here

# AI Analysis
GEMINI_API_KEY=your_gemini_api_key_here

# Smart Contract (Auto-updated)
CONTRACT_ADDRESS=${address}
ANALYZER_PRIVATE_KEY=your_analyzer_wallet_private_key

# Network Configuration
NODE_ENV=development
PORT=3001

# CORS
FRONTEND_URL=http://localhost:3000

# Testnet RPC URLs
SEPOLIA_RPC_URL=https://eth-sepolia.g.alchemy.com/v2/\${ALCHEMY_API_KEY}
AMOY_RPC_URL=https://rpc-amoy.polygon.technology/
ZETACHAIN_RPC_URL=https://zetachain-athens-evm.blockpi.network/v1/rpc/public
`;
    
    fs.writeFileSync(backendEnvPath, backendEnvContent);
    console.log("‚úÖ Backend configuration updated for testnet");
}

async function updateFrontendConfig(address: string, abi: any[]) {
    console.log("üé® Updating frontend configuration...");
    
    const frontendConfigPath = path.join(__dirname, '../../frontend/src/lib/contracts.ts');
    const frontendConfig = `// Auto-generated by deployment script - TESTNET CONFIGURATION
export const OMNIPASS_CONTRACT = {
  address: "${address}" as const,
  chainId: 7001,
  network: "zetachain-testnet"
};

export const OMNIPASS_ABI = ${JSON.stringify(abi, null, 2)} as const;

// Contract interaction helpers
export const getContractConfig = () => ({
  address: OMNIPASS_CONTRACT.address,
  abi: OMNIPASS_ABI,
  chainId: OMNIPASS_CONTRACT.chainId
});

// Supported testnet chains configuration
export const SUPPORTED_CHAINS = [
  {
    id: 11155111,
    name: 'Sepolia',
    nativeCurrency: { name: 'Sepolia ETH', symbol: 'ETH', decimals: 18 },
    rpcUrls: ['https://eth-sepolia.g.alchemy.com/v2/'],
    blockExplorerUrls: ['https://sepolia.etherscan.io'],
    testnet: true,
    faucetUrl: 'https://sepoliafaucet.com/'
  },
  {
    id: 80002,
    name: 'Polygon Amoy',
    nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
    rpcUrls: ['https://rpc-amoy.polygon.technology/'],
    blockExplorerUrls: ['https://amoy.polygonscan.com'],
    testnet: true,
    faucetUrl: 'https://faucet.polygon.technology/'
  },
  {
    id: 7001,
    name: 'ZetaChain Testnet',
    nativeCurrency: { name: 'ZETA', symbol: 'ZETA', decimals: 18 },
    rpcUrls: ['https://zetachain-athens-evm.blockpi.network/v1/rpc/public'],
    blockExplorerUrls: ['https://athens3.explorer.zetachain.com'],
    testnet: true,
    faucetUrl: 'https://labs.zetachain.com/get-zeta'
  }
] as const;
`;
    
    const frontendConfigDir = path.dirname(frontendConfigPath);
    if (!fs.existsSync(frontendConfigDir)) {
        fs.mkdirSync(frontendConfigDir, { recursive: true });
    }
    
    fs.writeFileSync(frontendConfigPath, frontendConfig);
    
    const frontendEnvPath = path.join(__dirname, '../../frontend/.env.local.example');
    const frontendEnvContent = `# TESTNET CONFIGURATION
# WalletConnect Configuration
NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID=your_walletconnect_project_id

# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:3001/api

# Contract Configuration (Auto-updated)
NEXT_PUBLIC_CONTRACT_ADDRESS=${address}

# Environment
NEXT_PUBLIC_ENVIRONMENT=testnet
NEXT_PUBLIC_NETWORK=zetachain-testnet
NEXT_PUBLIC_CHAIN_ID=7001
`;
    
    fs.writeFileSync(frontendEnvPath, frontendEnvContent);
    console.log("‚úÖ Frontend configuration updated for testnet");
}

async function main() {
    console.log("üöÄ Starting testnet deployment with retry logic...");

    const { ethers, artifacts } = hre;

    const signers: Signer[] = await ethers.getSigners();
    const deployer: Signer = signers[0];
    const deployerAddress = await deployer.getAddress();
    console.log("üìù Deploying with account:", deployerAddress);

    const balance = await ethers.provider.getBalance(deployerAddress);
    console.log("üí∞ Account balance:", ethers.formatEther(balance), "ZETA");

    // Verify we're on testnet
    const network = await ethers.provider.getNetwork();
    if (network.chainId !== 7001n) {
        throw new Error(`‚ùå Wrong network! Expected ZetaChain testnet (7001), got ${network.chainId}`);
    }

    const SYSTEM_CONTRACT_ADDRESS = "0x91d18e54DAf4F677cB28167158d6dd21F6aB3921";

    console.log("üî® Deploying OmniPassCredential to ZetaChain testnet...");
    console.log("üîß System Contract:", SYSTEM_CONTRACT_ADDRESS);

    try {
        // Deploy with retry logic and proper typing
        const contract = await deployWithRetry("OmniPassCredential", [SYSTEM_CONTRACT_ADDRESS]);
        
        const contractAddress = await contract.getAddress();
        console.log("‚úÖ OmniPassCredential deployed to:", contractAddress);
        console.log("üîó View on explorer: https://athens3.explorer.zetachain.com/address/" + contractAddress);

        // Get the ABI
        const artifact = await artifacts.readArtifact("OmniPassCredential");
        const contractABI = artifact.abi;

        // Get deployment info
        const deployTx = contract.deploymentTransaction();
        let gasUsed = "unknown";
        
        if (deployTx) {
            const receipt = await ethers.provider.getTransactionReceipt(deployTx.hash);
            if (receipt) {
                gasUsed = receipt.gasUsed.toString();
            }
        }

        // Save deployment info
        const deploymentInfo = {
            address: contractAddress,
            abi: contractABI,
            network: "zetachain-testnet",
            chainId: 7001,
            deployedAt: new Date().toISOString(),
            deployer: deployerAddress,
            constructorArgs: [SYSTEM_CONTRACT_ADDRESS],
            gasUsed: gasUsed
        };

        // Create deployments directory if it doesn't exist
        const deploymentsDir = path.join(__dirname, '../deployments');
        if (!fs.existsSync(deploymentsDir)) {
            fs.mkdirSync(deploymentsDir, { recursive: true });
        }

        // Save deployment info to JSON
        fs.writeFileSync(
            path.join(deploymentsDir, 'OmniPassCredential.json'),
            JSON.stringify(deploymentInfo, null, 2)
        );
        console.log("üíæ Deployment info saved to deployments/OmniPassCredential.json");

        // Update backend and frontend configurations
        await updateBackendConfig(contractAddress, contractABI);
        await updateFrontendConfig(contractAddress, contractABI);

        // Authorize the analyzer with retry logic
        if (process.env.ANALYZER_PRIVATE_KEY) {
            console.log("üîê Setting up analyzer authorization...");
            const analyzerWallet = new ethers.Wallet(process.env.ANALYZER_PRIVATE_KEY, ethers.provider);
            const analyzerAddress = await analyzerWallet.getAddress();
            
            // Use retry logic instead of direct tx.wait()
            await executeTransactionWithRetry(
                () => contract.setAnalyzerAuthorization(analyzerAddress, true),
                "Authorizing analyzer wallet"
            );
            
            console.log("‚úÖ Analyzer authorized:", analyzerAddress);
        } else {
            console.log("‚ö†Ô∏è ANALYZER_PRIVATE_KEY not set - skipping analyzer authorization");
        }

        console.log("\nüéâ Testnet deployment and configuration complete!");
        console.log("üìã Next steps:");
        console.log("1. Get testnet tokens from faucets if needed.");
        console.log("2. Ensure your .env files are up to date with any new keys.");
        console.log("3. Restart your backend and frontend servers.");
        console.log("4. Test contract interaction on the testnet.");

    } catch (error: any) {
        console.error("\nüí• Deployment failed:", error.message);
        throw error;
    }
}

main().catch((error) => {
    console.error("‚ùå Deployment failed:", error);
    process.exitCode = 1;
});
